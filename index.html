<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Majorbeam | AR Engine Lab</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* Learning Overlay UI */
        #ui-overlay {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 400px;
            background: rgba(20, 20, 20, 0.85);
            backdrop-filter: blur(5px);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        #instruction {
            font-size: 15px;
            margin: 0;
            line-height: 1.4;
        }

        /* Container for the AR Button */
        #ar-button-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 11;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <p id="instruction"><b>Step 1:</b> Point your camera at the floor and move it around to find a surface. Tap the ring to place the engine.</p>
    </div>

    <div id="ar-button-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let container;
        let camera, scene, renderer;
        let controller;

        let reticle; // The placement ring
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        let engineModel = null;
        let isPlaced = false;

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            // Camera setup
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Lighting: Essential for seeing 3D models properly
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 5, 5);
            scene.add(dirLight);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // IMPORTANT: Enable XR
            container.appendChild(renderer.domElement);

            // Create the AR Button with "hit-test" feature enabled
            const button = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay'],
                domOverlay: { root: document.getElementById('ui-overlay') }
            });
            document.getElementById('ar-button-container').appendChild(button);

            // 1. Load the 3D Model
            const loader = new GLTFLoader();
            // Load the local radial pneumatic engine GLB model
            const MODEL_URL = '3d_printable_radial_pneumatic_engine.glb';

            loader.load(MODEL_URL, (gltf) => {
                engineModel = gltf.scene;
                engineModel.scale.set(0.2, 0.2, 0.2); // Set initial scale
                engineModel.visible = false;
                scene.add(engineModel);
            });

            // 2. The Reticle (The "Target" on the floor)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 0.12, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // 3. User Interaction: Tap to place
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            window.addEventListener('resize', onWindowResize);

            // 4. Basic Gesture: Rotation via touch dragging
            let startX;
            window.addEventListener('touchstart', (e) => {
                if (isPlaced) startX = e.touches[0].pageX;
            });

            window.addEventListener('touchmove', (e) => {
                if (isPlaced && engineModel && e.touches.length === 1) {
                    const deltaX = e.touches[0].pageX - startX;
                    engineModel.rotation.y += deltaX * 0.01;
                    startX = e.touches[0].pageX;
                }
            });
        }

        function onSelect() {
            if (reticle.visible && engineModel) {
                // Move engine to reticle position
                engineModel.position.setFromMatrixPosition(reticle.matrix);
                engineModel.visible = true;
                isPlaced = true;
                
                // Update UI text
                document.getElementById('instruction').innerHTML = "<b>Step 1 Complete:</b> Observe the structure. Drag your finger horizontally to rotate the engine.";
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
